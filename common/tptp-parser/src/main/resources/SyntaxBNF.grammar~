%header%
GRAMMARTYPE = "LL"

%tokens%

%productions%


<TPTP_file>            ::= <TPTP_input>*
<TPTP_input>           ::= <annotated_formula> | <include>


<annotated_formula>    ::= <thf_annotated> | <tfx_annotated> | <tff_annotated> |
                           <tcf_annotated> | <fof_annotated> | <cnf_annotated> |
                           <tpi_annotated>

<tpi_annotated>        ::= tpi(<name>,<formula_role>,<tpi_formula> <annotations>).
<tpi_formula>          ::= <fof_formula>
<thf_annotated>        ::= thf(<name>,<formula_role>,<thf_formula>
                           <annotations>).
<tfx_annotated>        ::= tfx(<name>,<formula_role>,<tfx_formula>
                           <annotations>).
<tff_annotated>        ::= tff(<name>,<formula_role>,<tff_formula>
                           <annotations>).
<tcf_annotated>        ::= tcf(<name>,<formula_role>,<tcf_formula>
                           <annotations>).
<fof_annotated>        ::= fof(<name>,<formula_role>,<fof_formula>
                           <annotations>).
<cnf_annotated>        ::= cnf(<name>,<formula_role>,<cnf_formula>
                           <annotations>).
<annotations>          ::= ,<source> <optional_info> | <null>


<formula_role>         ::= <lower_word>
<formula_role>         :== axiom | hypothesis | definition | assumption |
                           lemma | theorem | corollary | conjecture |
                           negated_conjecture | plain | type |
                           fi_domain | fi_functors | fi_predicates | unknown


<thf_formula>          ::= <thf_logic_formula> | <thf_sequent>
<thf_logic_formula>    ::= <thf_binary_formula> | <thf_unitary_formula> |
                           <thf_type_formula> | <thf_subtype>
<thf_binary_formula>   ::= <thf_binary_pair> | <thf_binary_tuple> |
                           <thf_binary_type>


<thf_binary_pair>      ::= <thf_unitary_formula> <thf_pair_connective>
                           <thf_unitary_formula>
<thf_binary_tuple>     ::= <thf_or_formula> | <thf_and_formula> |
                           <thf_apply_formula>
<thf_or_formula>       ::= <thf_unitary_formula> <vline> <thf_unitary_formula> |
                           <thf_or_formula> <vline> <thf_unitary_formula>
<thf_and_formula>      ::= <thf_unitary_formula> & <thf_unitary_formula> |
                           <thf_and_formula> & <thf_unitary_formula>




<thf_apply_formula>    ::= <thf_unitary_formula> @ <thf_unitary_formula> |
                           <thf_apply_formula> @ <thf_unitary_formula>




<thf_unitary_formula>  ::= <thf_quantified_formula> | <thf_unary_formula> |
                           <thf_atom> | <thf_conditional> | <thf_let> |
                           <thf_tuple> | (<thf_logic_formula>)

<thf_quantified_formula> ::= <thf_quantification> <thf_unitary_formula>
<thf_quantification>   ::= <thf_quantifier> [<thf_variable_list>] :
<thf_variable_list>    ::= <thf_variable> | <thf_variable>,<thf_variable_list>
<thf_variable>         ::= <thf_typed_variable> | <variable>
<thf_typed_variable>   ::= <variable> : <thf_top_level_type>


<thf_unary_formula>    ::= <thf_unary_connective> (<thf_logic_formula>)
<thf_atom>             ::= <thf_function> | <variable> | <defined_term> |
                           <thf_conn_term>



<thf_function>         ::= <atom> | <functor>(<thf_arguments>) |
                           <defined_functor>(<thf_arguments>) |
                           <system_functor>(<thf_arguments>)


<thf_conn_term>        ::= <thf_pair_connective> | <assoc_connective> |
                           <thf_unary_connective>



<thf_conditional>      ::= $ite(<thf_logic_formula>,<thf_logic_formula>,
                            <thf_logic_formula>)


<thf_let>              ::= $let(<thf_unitary_formula>,<thf_formula>)
<thf_let>              :== $let(<thf_let_defns>,<thf_formula>)
<thf_let_defns>        :== <thf_let_defn> | [<thf_let_defn_list>]
<thf_let_defn_list>    :== <thf_let_defn> | <thf_let_defn>,<thf_let_defn_list>
<thf_let_defn>         :== <thf_let_quantified_defn> | <thf_let_plain_defn>
<thf_let_quantified_defn> :== <thf_quantification> (<thf_let_plain_defn>)
<thf_let_plain_defn>   :== <thf_let_defn_LHS> <assignment> <thf_formula>
<thf_let_defn_LHS>     :== <constant> | <functor>(<fof_arguments>) | 
                           <thf_tuple>

<thf_arguments>        ::= <thf_formula_list>


<thf_type_formula>     ::= <thf_typeable_formula> : <thf_top_level_type>
<thf_typeable_formula> ::= <thf_atom> | (<thf_logic_formula>)
<thf_subtype>          ::= <thf_atom> <subtype_sign> <thf_atom>


<thf_type_formula>     :== <constant> : <thf_top_level_type>


<thf_top_level_type>   ::= <thf_unitary_type> | <thf_mapping_type> |
                           <thf_apply_type>


<thf_unitary_type>     ::= <thf_unitary_formula>
<thf_apply_type>       ::= <thf_apply_formula>
<thf_binary_type>      ::= <thf_mapping_type> | <thf_xprod_type> |
                           <thf_union_type>
<thf_mapping_type>     ::= <thf_unitary_type> <arrow> <thf_unitary_type> |
                           <thf_unitary_type> <arrow> <thf_mapping_type>
<thf_xprod_type>       ::= <thf_unitary_type> <star> <thf_unitary_type> |
                           <thf_xprod_type> <star> <thf_unitary_type>
<thf_union_type>       ::= <thf_unitary_type> <plus> <thf_unitary_type> |
                           <thf_union_type> <plus> <thf_unitary_type>


<thf_sequent>          ::= <thf_tuple> <gentzen_arrow> <thf_tuple> |
                           (<thf_sequent>)




<thf_tuple>            ::= [] | [<thf_formula_list>] | 
                           {} | {<thf_formula_list>}
<thf_formula_list>     ::= <thf_logic_formula> |
                           <thf_logic_formula>,<thf_formula_list>


<logic_defn_rule>      :== <logic_defn_LHS> <assignment> <logic_defn_RHS>
<logic_defn_LHS>       :== <logic_defn_value> | <thf_top_level_type>  | <name>
<logic_defn_LHS>       :== $constants | $quantification | $consequence |
                           $modalities



<logic_defn_RHS>       :== <logic_defn_value> | <thf_unitary_formula>
<logic_defn_value>     :== <defined_constant>
<logic_defn_value>     :== $rigid | $flexible |
                           $constant | $varying | $cumulative | $decreasing |
                           $local | $global |
                           $modal_system_K | $modal_system_T | $modal_system_D |
                           $modal_system_S4 | $modal_system_S5 |
                           $modal_axiom_K | $modal_axiom_T | $modal_axiom_B |
                           $modal_axiom_D | $modal_axiom_4 | $modal_axiom_5



<tfx_formula>          ::= <tfx_logic_formula> | <thf_sequent>
<tfx_logic_formula>    ::= <thf_logic_formula> 




<tff_formula>          ::= <tff_logic_formula> | <tff_typed_atom> |
                           <tff_sequent>
<tff_logic_formula>    ::= <tff_binary_formula> | <tff_unitary_formula> |
                           <tff_subtype>
<tff_binary_formula>   ::= <tff_binary_nonassoc> | <tff_binary_assoc>
<tff_binary_nonassoc>  ::= <tff_unitary_formula> <binary_connective>
                           <tff_unitary_formula>
<tff_binary_assoc>     ::= <tff_or_formula> | <tff_and_formula>
<tff_or_formula>       ::= <tff_unitary_formula> <vline> <tff_unitary_formula> |
                           <tff_or_formula> <vline> <tff_unitary_formula>
<tff_and_formula>      ::= <tff_unitary_formula> & <tff_unitary_formula> |
                           <tff_and_formula> & <tff_unitary_formula>
<tff_unitary_formula>  ::= <tff_quantified_formula> | <tff_unary_formula> |
                           <tff_atomic_formula> | <tff_conditional> | 
                           <tff_let> | (<tff_logic_formula>)

<tff_quantified_formula> ::= <fof_quantifier> [<tff_variable_list>] :
                           <tff_unitary_formula>
<tff_variable_list>    ::= <tff_variable> | <tff_variable>,<tff_variable_list>
<tff_variable>         ::= <tff_typed_variable> | <variable>
<tff_typed_variable>   ::= <variable> : <tff_atomic_type>
<tff_unary_formula>    ::= <unary_connective> <tff_unitary_formula> |
                           <fof_infix_unary>
<tff_atomic_formula>   ::= <fof_atomic_formula>
<tff_conditional>      ::= $ite_f(<tff_logic_formula>,<tff_logic_formula>,
                           <tff_logic_formula>)
<tff_let>              ::= $let_tf(<tff_let_term_defns>,<tff_formula>) |
                           $let_ff(<tff_let_formula_defns>,<tff_formula>)

<tff_let_term_defns>   ::= <tff_let_term_defn> | [<tff_let_term_list>]
<tff_let_term_list>    ::= <tff_let_term_defn> |
                           <tff_let_term_defn>,<tff_let_term_list>
<tff_let_term_defn>    ::= ! [<tff_variable_list>] : <tff_let_term_defn> |
                           <tff_let_term_binding>
<tff_let_term_binding> ::= <fof_plain_term> = <fof_term> | 
                           (<tff_let_term_binding>)
<tff_let_formula_defns> ::= <tff_let_formula_defn> | [<tff_let_formula_list>]
<tff_let_formula_list> ::= <tff_let_formula_defn> |
                           <tff_let_formula_defn>,<tff_let_formula_list>
<tff_let_formula_defn> ::= ! [<tff_variable_list>] : <tff_let_formula_defn> |
                           <tff_let_formula_binding>
<tff_let_formula_binding> ::= <fof_plain_atomic_formula> <=> 
                           <tff_unitary_formula> | (<tff_let_formula_binding>)

<tff_sequent>          ::= <tff_formula_tuple> <gentzen_arrow>
                           <tff_formula_tuple> | (<tff_sequent>)

<tff_formula_tuple>    ::= [] | [<tff_formula_tuple_list>]
<tff_formula_tuple_list> ::= <tff_logic_formula> |
                           <tff_logic_formula>,<tff_formula_tuple_list>


<tff_typed_atom>       ::= <untyped_atom> : <tff_top_level_type> |
                           (<tff_typed_atom>)

<tff_subtype>          ::= <untyped_atom> <subtype_sign> <atom> 


<tff_top_level_type>   ::= <tff_atomic_type> | <tff_mapping_type> |
                           <tf1_quantified_type> | (<tff_top_level_type>)
<tf1_quantified_type>  ::= !> [<tff_variable_list>] : <tff_monotype>
<tff_monotype>         ::= <tff_atomic_type> | (<tff_mapping_type>)
<tff_unitary_type>     ::= <tff_atomic_type> | (<tff_xprod_type>)
<tff_atomic_type>      ::= <type_constant> | <defined_type> |
                           <type_functor>(<tff_type_arguments>) | <variable>
<tff_type_arguments>   ::= <tff_atomic_type> |
                           <tff_atomic_type>,<tff_type_arguments>



<tff_mapping_type>     ::= <tff_unitary_type> <arrow> <tff_atomic_type>
<tff_xprod_type>       ::= <tff_unitary_type> <star> <tff_atomic_type> |
                           <tff_xprod_type> <star> <tff_atomic_type>



<tcf_formula>          ::= <tcf_logic_formula> | <tff_typed_atom>
<tcf_logic_formula>    ::= <tcf_quantified_formula> | <cnf_formula>
<tcf_quantified_formula> ::= ! [<tff_variable_list>] : <cnf_formula>



<fof_formula>          ::= <fof_logic_formula> | <fof_sequent>
<fof_logic_formula>    ::= <fof_binary_formula> | <fof_unitary_formula>

<fof_binary_formula>   ::= <fof_binary_nonassoc> | <fof_binary_assoc>


<fof_binary_nonassoc>  ::= <fof_unitary_formula> <binary_connective>
                           <fof_unitary_formula>

<fof_binary_assoc>     ::= <fof_or_formula> | <fof_and_formula>
<fof_or_formula>       ::= <fof_unitary_formula> <vline> <fof_unitary_formula> |
                           <fof_or_formula> <vline> <fof_unitary_formula>
<fof_and_formula>      ::= <fof_unitary_formula> & <fof_unitary_formula> |
                           <fof_and_formula> & <fof_unitary_formula>


<fof_unitary_formula>  ::= <fof_quantified_formula> | <fof_unary_formula> |
                           <fof_atomic_formula> | (<fof_logic_formula>)

<fof_quantified_formula> ::= <fof_quantifier> [<fof_variable_list>] :
                           <fof_unitary_formula>
<fof_variable_list>    ::= <variable> | <variable>,<fof_variable_list>
<fof_unary_formula>    ::= <unary_connective> <fof_unitary_formula> |
                           <fof_infix_unary>

<fof_infix_unary>      ::= <fof_term> <infix_inequality> <fof_term>
<fof_atomic_formula>   ::= <fof_plain_atomic_formula> | 
                           <fof_defined_atomic_formula> |
                           <fof_system_atomic_formula>
<fof_plain_atomic_formula> ::= <fof_plain_term>
<fof_plain_atomic_formula> :== <proposition> | <predicate>(<fof_arguments>)
<fof_defined_atomic_formula> ::= <fof_defined_plain_formula> | 
                           <fof_defined_infix_formula>
<fof_defined_plain_formula> ::= <fof_defined_plain_term>
<fof_defined_plain_formula> :== <defined_proposition> | 
                           <defined_predicate>(<fof_arguments>)
<fof_defined_infix_formula> ::= <fof_term> <defined_infix_pred> <fof_term>

<fof_system_atomic_formula> ::= <fof_system_term>





<fof_plain_term>       ::= <constant> | <functor>(<fof_arguments>)

<fof_defined_term>     ::= <defined_term> | <fof_defined_atomic_term>
<fof_defined_atomic_term>  ::= <fof_defined_plain_term>



<fof_defined_plain_term>   ::= <defined_constant> | 
                           <defined_functor>(<fof_arguments>)

<fof_system_term>      ::= <system_constant> | <system_functor>(<fof_arguments>)

<fof_arguments>        ::= <fof_term> | <fof_term>,<fof_arguments>





<fof_term>             ::= <fof_function_term> | <variable> | 
                           <tff_conditional_term> | <tff_let_term> | 
                           <tff_tuple_term>
<fof_function_term>    ::= <fof_plain_term> | <fof_defined_term> | 
                           <fof_system_term>


<tff_conditional_term> ::= $ite_t(<tff_logic_formula>,<fof_term>,<fof_term>)


<tff_let_term>         ::= $let_ft(<tff_let_formula_defns>,<fof_term>) |
                           $let_tt(<tff_let_term_defns>,<fof_term>)

<tff_tuple_term>       ::= {} | {<fof_arguments>}


<fof_sequent>          ::= <fof_formula_tuple> <gentzen_arrow>
                           <fof_formula_tuple> | (<fof_sequent>)

<fof_formula_tuple>    ::= [] | [<fof_formula_tuple_list>]
<fof_formula_tuple_list> ::= <fof_logic_formula> |
                           <fof_logic_formula>,<fof_formula_tuple_list>


<cnf_formula>          ::= <disjunction> | (<disjunction>)
<disjunction>          ::= <literal> | <disjunction> <vline> <literal>
<literal>              ::= <fof_atomic_formula> | ~ <fof_atomic_formula> |
                           <fof_infix_unary>



<thf_quantifier>       ::= <fof_quantifier> | <th0_quantifier> |
                           <th1_quantifier>

<th1_quantifier>       ::= !> | ?*
<th0_quantifier>       ::= ^ | @+ | @-
<thf_pair_connective>  ::= <infix_equality> | <infix_inequality> |
                           <binary_connective> | <assignment>
<thf_unary_connective> ::= <unary_connective> | <th1_unary_connective>
<th1_unary_connective> ::= !! | ?? | @@+ | @@- | @=

<subtype_sign>         ::= <<



<fof_quantifier>       ::= ! | ?
<binary_connective>    ::= <=> | => | <= | <~> | ~<vline> | ~&
<assoc_connective>     ::= <vline> | &
<unary_connective>     ::= ~

<gentzen_arrow>        ::= -->
<assignment>           ::= :=


<type_constant>        ::= <type_functor>
<type_functor>         ::= <atomic_word>
<defined_type>         ::= <atomic_defined_word>
<defined_type>         :== $oType | $o | $iType | $i | $tType |
                           $real | $rat | $int





<system_type>          :== <atomic_system_word>


<atom>                 ::= <untyped_atom> | <defined_constant>
<untyped_atom>         ::= <constant> | <system_constant>

<defined_proposition>  :== <atomic_defined_word>
<defined_proposition>  :== $true | $false
<defined_predicate>    :== <atomic_defined_word>
<defined_predicate>    :== $distinct |
                           $less | $lesseq | $greater | $greatereq |
                           $is_int | $is_rat |
                           $box_P | $box_i | $box_int | $box |
                           $dia_P | $dia_i | $dia_int | $dia



<defined_infix_pred>   ::= <infix_equality> | <assignment>
<infix_equality>       ::= =
<infix_inequality>     ::= !=

<constant>             ::= <functor>
<functor>              ::= <atomic_word>
<system_constant>      ::= <system_functor>
<system_functor>       ::= <atomic_system_word>
<defined_constant>     ::= <defined_functor>
<defined_functor>      ::= <atomic_defined_word>
<defined_functor>      :== $uminus | $sum | $difference | $product |
                           $quotient | $quotient_e | $quotient_t | $quotient_f |
                           $remainder_e | $remainder_t | $remainder_f |
                           $floor | $ceiling | $truncate | $round |
                           $to_int | $to_rat | $to_real
<defined_term>         ::= <number> | <distinct_object>
<variable>             ::= <upper_word>


<source>               ::= <general_term>
<source>               :== <dag_source> | <internal_source> |
                           <external_source> | unknown | [<sources>]


<sources>              :== <source> | <source>,<sources>


<dag_source>           :== <name> | <inference_record>
<inference_record>     :== inference(<inference_rule>,<useful_info>,
                           <inference_parents>)
<inference_rule>       :== <atomic_word>






<inference_parents>    :== [] | [<parent_list>]
<parent_list>          :== <parent_info> | <parent_info>,<parent_list>
<parent_info>          :== <source> <parent_details>
<parent_details>       :== :<general_list> | <null>
<internal_source>      :== introduced(<intro_type> <optional_info>)
<intro_type>           :== definition | axiom_of_choice | tautology | assumption


<external_source>      :== <file_source> | <theory> | <creator_source>
<file_source>          :== file(<file_name> <file_info>)
<file_info>            :== ,<name> | <null>
<theory>               :== theory(<theory_name> <optional_info>)
<theory_name>          :== equality | ac



<creator_source>       :== creator(<creator_name> <optional_info>)
<creator_name>         :== <atomic_word>


<optional_info>        ::= ,<useful_info> | <null>
<useful_info>          ::= <general_list>
<useful_info>          :== [] | [<info_items>]
<info_items>           :== <info_item> | <info_item>,<info_items>
<info_item>            :== <formula_item> | <inference_item> |
                           <general_function>

<formula_item>         :== <description_item> | <iquote_item>
<description_item>     :== description(<atomic_word>)
<iquote_item>          :== iquote(<atomic_word>)




<inference_item>       :== <inference_status> | <assumptions_record> |
                           <new_symbol_record> | <refutation>
<inference_status>     :== status(<status_value>) | <inference_info>

<status_value>         :== suc | unp | sap | esa | sat | fsa | thm | eqv | tac |
                           wec | eth | tau | wtc | wth | cax | sca | tca | wca |
                           cup | csp | ecs | csa | cth | ceq | unc | wcc | ect |
                           fun | uns | wuc | wct | scc | uca | noc






<inference_info>       :== <inference_rule>(<atomic_word>,<general_list>)


<assumptions_record>   :== assumptions([<name_list>])


<refutation>           :== refutation(<file_source>)

<new_symbol_record>    :== new_symbols(<atomic_word>,[<new_symbol_list>])
<new_symbol_list>      :== <principal_symbol> |
                           <principal_symbol>,<new_symbol_list>

<principal_symbol>   :== <functor> | <variable>


<include>              ::= include(<file_name> <formula_selection>).
<formula_selection>    ::= ,[<name_list>] | <null>
<name_list>            ::= <name> | <name>,<name_list>


<general_term>         ::= <general_data> | <general_data>:<general_term> |
                           <general_list>
<general_data>         ::= <atomic_word> | <general_function> |
                           <variable> | <number> | <distinct_object> |
                           <formula_data>
<general_function>     ::= <atomic_word>(<general_terms>)


<general_data>         :== bind(<variable>,<formula_data>)
<formula_data>         ::= $thf(<thf_formula>) | $tff(<tff_formula>) |
                           $fof(<fof_formula>) | $cnf(<cnf_formula>) |
                           $fot(<fof_term>)
<general_list>         ::= [] | [<general_terms>]
<general_terms>        ::= <general_term> | <general_term>,<general_terms>


<name>                 ::= <atomic_word> | <integer>

<atomic_word>          ::= <lower_word> | <single_quoted>






<atomic_defined_word>  ::= <dollar_word>
<atomic_system_word>   ::= <dollar_dollar_word>
<number>               ::= <integer> | <rational> | <real>



<file_name>            ::= <single_quoted>
<null>                 ::=


<comment>              ::- <comment_line>|<comment_block>
<comment_line>         ::- [%]<printable_char>*
<comment_block>        ::: [/][*]<not_star_slash>[*][*]*[/]
<not_star_slash>       ::: ([^*]*[*][*]*[^/*])*[^*]*


<single_quoted>        ::- <single_quote> <sq_char> <sq_char>*<single_quote>


<distinct_object>      ::- <double_quote> <do_char>*<double_quote>


<dollar_word>          ::- <dollar> <lower_word>
<dollar_dollar_word>   ::- <dollar> <dollar> <lower_word>
<upper_word>           ::- <upper_alpha> <alpha_numeric>*
<lower_word>           ::- <lower_alpha> <alpha_numeric>*


<vline>                ::- [|]
<star>                 ::- [*]
<plus>                 ::- [+]
<arrow>                ::- [>]
<less_sign>            ::- [<]


<real>                 ::- (<signed_real>|<unsigned_real>)
<signed_real>          ::- <sign> <unsigned_real>
<unsigned_real>        ::- (<decimal_fraction>|<decimal_exponent>)
<rational>             ::- (<signed_rational>|<unsigned_rational>)
<signed_rational>      ::- <sign> <unsigned_rational>
<unsigned_rational>    ::- <decimal> <slash> <positive_decimal>
<integer>              ::- (<signed_integer>|<unsigned_integer>)
<signed_integer>       ::- <sign> <unsigned_integer>
<unsigned_integer>     ::- <decimal>
<decimal>              ::- (<zero_numeric>|<positive_decimal>)
<positive_decimal>     ::- <non_zero_numeric> <numeric>*
<decimal_exponent>     ::- (<decimal>|<decimal_fraction>)<exponent> <exp_integer>
<decimal_fraction>     ::- <decimal> <dot_decimal>
<dot_decimal>          ::- <dot> <numeric> <numeric>*
<exp_integer>          ::- (<signed_exp_integer>|<unsigned_exp_integer>)
<signed_exp_integer>   ::- <sign> <unsigned_exp_integer>
<unsigned_exp_integer> ::- <numeric> <numeric>*


<percentage_sign>      ::: [%]
<double_quote>         ::: ["]
<do_char>              ::: ([\40-\41\43-\133\135-\176]|[\\]["\\])
<single_quote>         ::: [']

<sq_char>              ::: ([\40-\46\50-\133\135-\176]|[\\]['\\])
<sign>                 ::: [+-]
<dot>                  ::: [.]
<exponent>             ::: [Ee]
<slash>                ::: [/]
<zero_numeric>         ::: [0]
<non_zero_numeric>     ::: [1-9]
<numeric>              ::: [0-9]
<lower_alpha>          ::: [a-z]
<upper_alpha>          ::: [A-Z]
<alpha_numeric>        ::: (<lower_alpha>|<upper_alpha>|<numeric>|[_])
<dollar>               ::: [$]
<printable_char>       ::: .



<viewable_char>        ::: [.\n]

